name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      deployment_target:
        description: 'Deployment target'
        required: true
        default: 'none'
        type: choice
        options:
          - none
          - lambda
          - ecs
          - elastic-beanstalk

env:
  JAVA_VERSION: '17'
  MAVEN_OPTS: -Xmx1024m
  AWS_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}

jobs:
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'

      - name: Cache Maven packages
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Build with Maven
        run: mvn clean compile -B

      - name: Run tests
        run: mvn test -B
        env:
          DB_URL: jdbc:postgresql://localhost:5432/testdb
          DB_USERNAME: test
          DB_PASSWORD: test
          API_KEY: test-api-key

      - name: Generate test report
        if: always()
        run: |
          if [ -d "target/surefire-reports" ]; then
            echo "Test results:"
            find target/surefire-reports -name "*.xml" -exec cat {} \;
          fi

      - name: Package application
        run: mvn package -DskipTests -B

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ehr-spring-core-jar
          path: target/ehr-spring-core-*.jar
          retention-days: 7

  deploy-lambda:
    name: Deploy to AWS Lambda
    needs: build-and-test
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deployment_target == 'lambda')
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: ehr-spring-core-jar
          path: ./target

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to Lambda
        run: |
          # Find the JAR file
          JAR_FILE=$(ls target/ehr-spring-core-*.jar | head -n 1)

          # Update Lambda function code
          aws lambda update-function-code \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME || 'ehr-spring-core' }} \
            --zip-file fileb://$JAR_FILE

          # Wait for update to complete
          aws lambda wait function-updated \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME || 'ehr-spring-core' }}

          # Update environment variables
          aws lambda update-function-configuration \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME || 'ehr-spring-core' }} \
            --environment Variables="{
              DB_URL=${{ secrets.DB_URL }},
              DB_USERNAME=${{ secrets.DB_USERNAME }},
              DB_PASSWORD=${{ secrets.DB_PASSWORD }},
              API_KEY=${{ secrets.API_KEY }},
              DB_DDL_AUTO=validate,
              DB_SHOW_SQL=false
            }"

          echo "Lambda deployment completed successfully"

  deploy-ecs:
    name: Deploy to AWS ECS
    needs: build-and-test
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deployment_target == 'ecs')
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: ehr-spring-core-jar
          path: ./target

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY || 'ehr-spring-core' }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Create Dockerfile if it doesn't exist
          if [ ! -f Dockerfile ]; then
            cat > Dockerfile <<'EOF'
          FROM eclipse-temurin:17-jre-alpine
          WORKDIR /app
          COPY target/ehr-spring-core-*.jar app.jar
          EXPOSE 8080
          ENTRYPOINT ["java", "-jar", "app.jar"]
          EOF
          fi

          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Update ECS service
        env:
          ECS_CLUSTER: ${{ secrets.ECS_CLUSTER || 'ehr-cluster' }}
          ECS_SERVICE: ${{ secrets.ECS_SERVICE || 'ehr-spring-core-service' }}
          ECS_TASK_DEFINITION: ${{ secrets.ECS_TASK_DEFINITION || 'ehr-spring-core-task' }}
        run: |
          # Force new deployment
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --force-new-deployment

          # Wait for service to stabilize
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE

          echo "ECS deployment completed successfully"

  deploy-elastic-beanstalk:
    name: Deploy to Elastic Beanstalk
    needs: build-and-test
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deployment_target == 'elastic-beanstalk')
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: ehr-spring-core-jar
          path: ./target

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create deployment package
        run: |
          # Find the JAR file
          JAR_FILE=$(ls target/ehr-spring-core-*.jar | head -n 1)

          # Create .ebextensions if it doesn't exist
          mkdir -p .ebextensions

          # Create environment configuration
          cat > .ebextensions/environment.config <<'EOF'
          option_settings:
            aws:elasticbeanstalk:application:environment:
              SERVER_PORT: 5000
              JAVA_TOOL_OPTIONS: "-Xmx512m"
          EOF

          # Create deployment package
          zip -r deployment-package.zip $JAR_FILE .ebextensions Procfile 2>/dev/null || zip -r deployment-package.zip $JAR_FILE .ebextensions

          # Create Procfile if it doesn't exist
          if [ ! -f Procfile ]; then
            JAR_NAME=$(basename $JAR_FILE)
            echo "web: java -jar $JAR_NAME" > Procfile
            zip deployment-package.zip Procfile
          fi

      - name: Deploy to Elastic Beanstalk
        env:
          EB_APPLICATION: ${{ secrets.EB_APPLICATION || 'ehr-spring-core' }}
          EB_ENVIRONMENT: ${{ secrets.EB_ENVIRONMENT || 'ehr-spring-core-prod' }}
        run: |
          # Upload to S3
          VERSION_LABEL="v-${{ github.sha }}-$(date +%s)"
          S3_BUCKET="${{ secrets.EB_BUCKET || 'elasticbeanstalk-'$AWS_REGION }}"

          aws s3 cp deployment-package.zip s3://$S3_BUCKET/$EB_APPLICATION/$VERSION_LABEL.zip

          # Create application version
          aws elasticbeanstalk create-application-version \
            --application-name $EB_APPLICATION \
            --version-label $VERSION_LABEL \
            --source-bundle S3Bucket=$S3_BUCKET,S3Key=$EB_APPLICATION/$VERSION_LABEL.zip \
            --description "Deploy from GitHub Actions - ${{ github.sha }}"

          # Update environment
          aws elasticbeanstalk update-environment \
            --application-name $EB_APPLICATION \
            --environment-name $EB_ENVIRONMENT \
            --version-label $VERSION_LABEL

          # Wait for environment to be ready
          aws elasticbeanstalk wait environment-updated \
            --application-name $EB_APPLICATION \
            --environment-names $EB_ENVIRONMENT

          echo "Elastic Beanstalk deployment completed successfully"

  database-migration:
    name: Database Migration
    needs: build-and-test
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch')
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check database connectivity
        run: |
          # Install PostgreSQL client
          sudo apt-get update
          sudo apt-get install -y postgresql-client

          # Extract host from JDBC URL
          DB_HOST=$(echo "${{ secrets.DB_URL }}" | sed -n 's/.*:\/\/\([^:]*\):.*/\1/p')
          DB_PORT=$(echo "${{ secrets.DB_URL }}" | sed -n 's/.*:\([0-9]*\)\/.*/\1/p')
          DB_NAME=$(echo "${{ secrets.DB_URL }}" | sed -n 's/.*\/\([^?]*\).*/\1/p')

          echo "Testing connection to database: $DB_HOST:$DB_PORT/$DB_NAME"

          # Test connection
          PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
            -h "$DB_HOST" \
            -p "${DB_PORT:-5432}" \
            -U "${{ secrets.DB_USERNAME }}" \
            -d "$DB_NAME" \
            -c "SELECT version();" || echo "Database connection test completed"

      - name: Run database migration
        run: |
          echo "Database schema is managed by Hibernate with ddl-auto=validate in production"
          echo "If you need to run migrations, consider using Flyway or Liquibase"
          echo "For now, the application will validate the schema on startup"

          # If using Flyway, uncomment:
          # mvn flyway:migrate \
          #   -Dflyway.url="${{ secrets.DB_URL }}" \
          #   -Dflyway.user="${{ secrets.DB_USERNAME }}" \
          #   -Dflyway.password="${{ secrets.DB_PASSWORD }}"

  health-check:
    name: Health Check
    needs: [deploy-lambda, deploy-ecs, deploy-elastic-beanstalk]
    runs-on: ubuntu-latest
    if: always() && (needs.deploy-lambda.result == 'success' || needs.deploy-ecs.result == 'success' || needs.deploy-elastic-beanstalk.result == 'success')

    steps:
      - name: Wait for deployment
        run: sleep 30

      - name: Check application health
        run: |
          # Configure health check URL based on deployment target
          if [ -n "${{ secrets.HEALTH_CHECK_URL }}" ]; then
            HEALTH_URL="${{ secrets.HEALTH_CHECK_URL }}"
          elif [ -n "${{ secrets.APPLICATION_URL }}" ]; then
            HEALTH_URL="${{ secrets.APPLICATION_URL }}/actuator/health"
          else
            echo "No health check URL configured, skipping"
            exit 0
          fi

          echo "Checking health at: $HEALTH_URL"

          # Retry health check up to 5 times
          for i in {1..5}; do
            response=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" || echo "000")

            if [ "$response" = "200" ]; then
              echo "Health check passed (HTTP $response)"
              exit 0
            fi

            echo "Attempt $i: Health check returned HTTP $response, retrying in 10s..."
            sleep 10
          done

          echo "Health check failed after 5 attempts"
          exit 1
